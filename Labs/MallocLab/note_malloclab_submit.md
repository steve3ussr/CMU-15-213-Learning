

# 0 引言

## 0.1 背景

该Lab对应CSAPP课程中虚拟内存一章, 目的是写一个通用的动态内存分配器, 并且兼具效率和空间利用率. 这个Lab涉及到对内存模型的理解, 大量的强制转换, 还有对工程中妥协艺术的思考. 

对于我这个非科班出身 && 几乎不会C && 自学CSAPP的人来说, 这是目前做过的7个Lab中最复杂, 最容易写出Bug, 但也恰恰是最引人入胜的一个. 动不动出现的segment fault令人崩溃, 但在无数次调试后终于成功运行, 并且性能越来越好的成就感也难以忘怀. 

该Lab中使用的rep包括: 

```
    "short1-bal.rep"
    "short2-bal.rep"
    "amptjp-bal.rep"
    "cccp-bal.rep"
    "cp-decl-bal.rep"
    "expr-bal.rep"
    "coalescing-bal.rep"
    "random-bal.rep"
    "random2-bal.rep"
    "binary-bal.rep"
    "binary2-bal.rep"
    "realloc-bal.rep"
    "realloc2-bal.rep"
```

只使用默认的O2, 没有开O3. 



## 0.2 该Lab中的基础知识

在该lab中, 内存被紧密地划分为若干个内存块, 一个兼具分配速度和空间利用率的内存分配器需要: 

- **高效地找到一个空闲内存块**并且放置载荷
- 将空闲内存块与其他空闲内存块合并, **减少碎片, 节约空间**

---

为了合并空闲块, 我们需要知道一个块的大小和分配状态, 因此需要额外的标记. 

如同书上所说, 内存块需要一个header, 其中前29-bits用来表示块大小, 剩下的3个bits用来表示该块的状态 (free | alloc). 

另外该lab中内存**要求8 bytes对齐**, 因为CPU访问的内存地址 (载荷的分配地址) 必须是8的倍数; 例如分配的载荷可以从0x8008开始, 但是不能从0x8004开始. 因此每个块的大小必须为8的倍数; 既然如此, 块大小的标记中后3位确实可以省略. 



---

为了找到一个空闲块, 内存块在堆上的组织形式大概有两种:

1. array: 把内存看成一个大号数组, 根据一个内存块的大小, 找到其堆上**前一个/后一个块**; 

2. linked list: 根据一个内存块上的指针, 找到**上一个/下一个**空闲块 (空闲块不一定是紧挨着的, 也不一定是按地址排序的)

如果是双向链表, 找到上一个/下一个结点是很轻松的; 

如果是单向链表, 找到下一个结点也是很轻松的, 但找到上一个结点需要花费更多的时间, 仅此而已. 

如果是大号数组, 从一个内存块找到后一个内存块只需要计算bp (block pointer) + block size; 但找到前一个内存块不容易, 因为我们不知道前一个内存块的尺寸, 除非从头遍历一遍. 

**边界标记**可以解决这个问题, 每个内存块都包含了header和footer, 包含了相同的内容; 对于当前bp, -4 bytes是bp header, 再-4 bytes就是前一个块的footer, 用bp减去前一个块的大小, 就能得到前一个块的地址. 

## 0.3 部分基础宏定义

为了方便, 需要一些宏定义; 不同方案中会适当修改宏定义, 但总体区别不大. 

```c++
// 块大小对齐至8的倍数
#define ALIGNMENT 8
#define ALIGN(size) (((size) + (ALIGNMENT-1)) & ~0x7) 

// 一些基础定义
#define WSIZE               4
#define DSIZE               8
#define uint                unsigned int
#define CHUNKSIZE           (1<<12) // 4K
#define MAX(x, y)           ((x)>(y)? (x) : (y))
#define PACK(size, alloc)   ((size) | (alloc))

// 操作内存, 查询块的header/footer, 获取块大小和状态
#define GET(p)              (*(uint *)(p))
#define UNPACK_SIZE(p)      (GET(p) & (~0x7))
#define UNPACK_ALLOC(p)     (GET(p) & (0x1))
#define PUT(p, val)         (*(uint *)(p) = (val))

#define HDRP(bp)            ((char *)(bp) - WSIZE)
#define FTRP(bp)            ((char *)(bp) + GET_BLK_SIZE(bp) - DSIZE)

#define NEXT_BLKP(bp)       ((char *)(bp) + GET_BLK_SIZE(bp))
#define PREV_BLKP(bp)       ((char *)(bp) - UNPACK_SIZE(HDRP(bp) - WSIZE))

#define GET_BLK_SIZE(bp)    (UNPACK_SIZE(HDRP(bp)))
#define GET_BLK_ALLOC(bp)   (UNPACK_ALLOC(HDRP(bp)))

#define SET_BOUNDARY(bp, size, alloc)    do {PUT(HDRP(bp), PACK(size, alloc)); PUT(FTRP(bp), PACK(size, alloc));} while (0)

// 堆中最后一个footer, 其实是brk-8
#define LAST_FTR            (mem_heap_hi()+1-2*WSIZE)  
```



# 1 隐式空闲链表

## 1.1 内存块格式, 在堆上的分布

在该方案中, 内存块被简单的组织成一个紧密排列的大号数组, **通过块上标记的大小, 并且引入footer**, 可以把内存看作一个隐式的双向链表. 

堆上除了实际载荷, 还必须有prologue和epilogue块 (标记为alloc), 用于区分内存池的边界, 这样查找/合并内存的时候不会越界. 

- prologue块必须占据8个字节: 这样第一个带有实际payload的块将根据prologue的footer知道他的尺寸, 在以上的宏定义中, 如果想知道prologue块的分配状态就必须查看header, 因此prologue块必须占据8字节; 比大小更重要的是: **prologue的状态必须是alloc, 否则就会误合并**
- epilogue块可以只占据4字节: 堆上最后一个带有实际payload的块如果查询后一个块, 将定位到一个堆外的未定义的内存位置 (epilogue块的地址, 事实上也是brk指针的位置), 但查询其大小和状态只需要查看其header, 只要这个header在堆内就不会有问题
- 如果我们修改定义, 例如查询大小和状态时不看header而是看footer, 那prologue和epilogue的块大小就会反过来----但不管怎么说, 这两个块加在一起需要占用12字节, 而为了内存对齐, 还需要额外的空闲4字节. 

初始堆内存+一个16字节的空闲块在内存上是这样分布的:

```
| 8 Bytes | 8 Bytes | 8 Bytes | 8 Bytes |  
+----+----+----+====+====+====+====+----+---
| 00 |8/1 |8/1 |16/0|    |    |16/0|0/1 |
+----+----+----+====+====+====+====+----+---
           |         ^ payload bp        ^ epologue bp (brk)
           |                              
           ^ prologue bp (block pointer)
```

## 1.2 mm_init

- 初始分配16字节, 用于基础块和对齐
- **list_head (全局变量)** 为第一个块 (prologue) 的地址
- 可以分配一个初始内存 (例如分配4096字节)

## 1.3 extend_heap

- 扩展堆内存
- 在扩展堆内存时, 原先的 brk (epilogue bp)会作为新的块的bp, 而epilogue header会做作为新的块的header; 因此必须标记一个新的epilogue header
- 标记新扩展的块的大小和状态
- 新扩展的区域和前一块也许可以合并

## 1.4 coalesce

- 查询前后块的大小和状态, 根据状态的4种可能进入4个分支
- 前后都已分配: 什么都不干
- 前面空闲: 修改前一块的header尺寸+当前块的footer尺寸, 返回前一块
- 后面空闲: 修改当前块的header尺寸+后一块的footer尺寸, 返回当前块
- 都空闲: 修改前一块的header尺寸++后一块的footer尺寸, 返回前一块
- 在宏`SET_BOUNDARY`中, 先修改了bp的header, 然后根据header中的块大小找到footer并修改
- 有可能可以递归地合并

## 1.5 mm_malloc

- 先内存对齐, 将payload尺寸对齐到8, 再加上8字节的header, footer
- 查找堆中是否有足够大的空闲块, 如果存在就放置
- 如果没有, 就扩展并且放置

## 1.6 find_fit

> first-fit, 查找第一个满足尺寸要求的空闲块

- 从list_head (prologue) 开始, 查找后一个块
- 遇到第一个大于等于要求的free block就返回
- 当前块的尺寸为0时停止, 这表明当前块是epilogue
- 找不到就返回NULL

## 1.7 place

放置块时可能会产生碎片. 如果块大小为64, 但是payload只有8, 那会产生64-8-4-4大小的碎片 (以块内padding的形式存在). 所以根据情况可以分割块:

- 空闲尺寸小于16B: 无法分割为新的块, 因为一个块最小尺寸为16B
- 分割块: 可以分割块的前部或者后部, 在当前方案中将块的后部作为载荷, 实测这样结果更好
- 如果分割了块, 别忘记合并了空闲块

## 1.8 mm_free

- 将当前块标记为free
- 合并

## 1.9 mm_realloc

- 内存对齐
- 如果申请尺寸小于等于当前尺寸: 什么都不需要改
- 如果申请尺寸大于等于当前尺寸
  - 标准情况: alloc, memcpy, free
  - 特殊情况: 堆上后一个块为free, 并且尺寸合适, 直接合并两个块; **根据具体尺寸决定是否要分割一部分**
  - 更特殊的情况: 如果当前块为最后一个块, realloc可以直接扩展内存

这里还考虑了两点:

1. “如果申请尺寸大于等于当前尺寸, 并且前一个块为空闲”这种情况没有考虑, 因为这种情况可能会产生额外的memcpy
2. 如果当前块大小为128, 申请8的payload, 题目不允许把多余的内存作为空闲块释放掉, 题目要求保留这部分内存

## 1.10 得分

```
Results for mm malloc:
trace  valid  util     ops      secs  Kops
 0       yes   99%      12  0.000000     60000
 1       yes   90%      12  0.000000    120000
 2       yes   99%    5694  0.004296      1325
 3       yes  100%    5848  0.004300      1360
 4       yes   99%    6648  0.005876      1131
 5       yes  100%    5380  0.004351      1236
 6       yes   66%   14400  0.000097    148148
 7       yes   92%    4800  0.005159       930
 8       yes   91%    4800  0.005006       959
 9       yes   55%   12000  0.094872       126
10       yes   51%   24000  0.139474       172
11       yes   99%   14401  0.000120    120108
12       yes   87%   14401  0.000112    128466
Total          87%  112396  0.263663   426

Perf index = 52 (util) + 28 (thru) = 81/100
```

作为第一个方案, 空间利用率还不错, 但是速度显然比较慢; 不过后面的几个方案会改善的! 

# 2 显式空闲链表

## 2.1 内存块格式, 在堆上的分布

尽管各种算法都是`O(n)`的, 但如果我们在alloc时只检索空闲块, 那会提升运行效率. 为了减少查询块的大小和状态的次数, 在上个方案的基础上, 额外将所有空闲块组织成一个显式的链表, 这样分配内存时不需要查询状态为alloc的内存块.

**这个方案可以不需要footer**, 因为通过链表就可以知道上一个/下一个空闲块, 并通过内存地址+块大小判断块是否相邻; 这样可以节约微不足道的一些内存. 

并且必须在块中放置两个指针, 用于查找上一个/下一个空闲块. 

需要引入新的宏, 其中BK=back, FD=forward:

```c
#define FDP(bp)             (bp)
#define BKP(bp)             ((char *)(bp) + WSIZE)

// 查找上一个/下一个结点
#define FD(bp)              (GET(FDP(bp)))
#define BK(bp)              (GET(BKP(bp)))
```

## 2.2 mm_init

在我的实现中, prologue和epilogue相当于双向链表头尾的伪结点: 

- prologue的BK=NULL, 分配状态为alloc
- epilogue的FD=NULL, 分配状态为alloc

这两个dummy nodes每个都至少需要3个words, 分别储存header, fd, bk; 而根据隐式空闲链表中的分析, 并不需要额外的填充来保证内存对齐, 因此我们只需要申请6个words的内存. 

初始化时需要连接这个两个伪节点, prologue.FD=epilogue, epilogue.BK=prologue

为了方便, 还有**两个全局变量指向这两个结点: **`list_head, list_tail`

## 2.3 extend_heap

扩展内存除了调用sbrk之外, 还需要: 

- 找到内存块bp位置, 给header赋值
- sbrk后覆盖了epilogue的内容, 因此需要重建epilogue, 并且重新制定全局变量list_tail
- 类似于双向链表中插入结点的所有操作, 正确处理epilogue, BK of epilogue的关系: **这里并没有把新申请的内存直接加入空闲链表, 因为在调用extend_heap的场景中, 完全没必要把内存加入空闲链表, 直接分配就好了 (malloc找不到合适的位置, realloc位于尾部的块)**

## 2.4 coalesce

既然所有的空闲块都在链表中, 我们只需要查询当前bp的上一个/下一个结点的:

- 分配状态 (alloc说明结点为epilogue/prologue)
- 地址和大小: 用于判断块与块之间是否是紧邻的

如果链表的上一个/下一个结点是空闲的, 并且和bp在内存上是紧邻的, 那说明可以合并; **此时只需要回想一下双向链表的知识就可以正确合并相邻节点了**

## 2.5 mm_malloc

由于这个实现中内存块不需要footer, 并且每个内存块至少包含12字节的数据, 因此申请内存的时候应该这样内存对齐:

- 申请1-4: 载荷对齐至4, 块大小为16
- 申请5-12: 载荷对齐为12, 块大小为24
- 申请13-20: 载荷对齐为20, 块大小为32

寻找合适的空闲内存块, 否则就扩展内存; 最终放置

## 2.6 find_fit

遍历空闲链表, 寻找第一个足够大小的块

## 2.7 place

和之前差不多, 如果块内剩余空间小于16字节就无法分割; 否则就分割块. 

如果将载荷放置在块的前部, 那就需要修改链表, 写起来比较麻烦; 但如果将载荷优先放置在块的后部, 只需要:

- 修改块大小
- 执行合并

也许另一种方案更好, 但我是懒狗, 懒得写~

## 2.8 mm_free

这里有两种方法: 

1. LIFO: 将空闲块插入到链表的开头
2. **按地址排序**: 将空闲块插入到合适的位置

**按照地址排序**更有可能执行合并, 因此需要:

- 找到链表中第一个比当前块地址高的块curr (一定能找到, 因为没有块比epilogue大)
- 正确处理curr, 当前块bp, curr的前任prev之间的关系

## 2.9 mm_realloc

和隐式空闲链表的策略一样

## 2.10 得分

```
Results for mm malloc:
trace  valid  util     ops      secs  Kops
 0       yes   99%      12  0.000000     60000
 1       yes  100%      12  0.000000    120000
 2       yes   99%    5694  0.000178     31917
 3       yes  100%    5848  0.000164     35746
 4       yes   99%    6648  0.000193     34428
 5       yes  100%    5380  0.000172     31206
 6       yes   99%   14400  0.000077    187990
 7       yes   92%    4800  0.001743      2754
 8       yes   91%    4800  0.001808      2655
 9       yes   55%   12000  0.010435      1150
10       yes   51%   24000  0.053733       447
11       yes  100%   14401  0.000094    153202
12       yes   87%   14401  0.000095    150954
Total          90%  112396  0.068692  1636

Perf index = 54 (util) + 40 (thru) = 94/100
```

和隐式空闲链表相比, 在空间利用率上有小幅提升, 但速度却快了很多, 毕竟只需要遍历空闲的, 而非全部的内存块. 

## 2.11 邪修得分

注意到两件事情: 

当前版本在binary系列用例中的内存利用率较低. 以binary-bal为例, 它会按照64-448-64-448的顺序不断申请内存 (在内存上, 我们管理的内存块也是如此排列的), 然后释放所有大小为448的内存, 并且重新申请大小为512的内存. 

当释放这些448块后, 他们将无法被再次利用; **所以如果我们在申请448的块时, 手动将他的尺寸上调到512**, 那后续申请512的内存就可以重复利用这个块了. 两个binary系列中, 可以对尺寸为448和112的申请做特殊处理, 手动上调到512和128. 

另外注意到realloc的空间利用率为100%, 而realloc2的为87%: 这两个用例本质上是一样的, 只不过realloc2的数值比例更极端, 浪费的内存更多. 

如果初始内存为空, 只看realloc2的前几步, 堆上内存是这样的 (之后不断变大的realloc不会产生内存碎片, 因为这个块位于堆末尾, realloc时直接extend):

如果我们在mm_init初始分配了一块区域, 足以放下两个16的申请 (这需要64字节的空间), 并且插入一个alloc内存块避免合并, 同样的前4个步骤将不会再产生内存碎片: 

---

使用以上两个邪修后的分数如下所示.

- 空间利用率和我们预想的一样大大提升
- 新增加的 if 条件分支略微降低了性能
- 但新增的条件分支大大提升了binary和realloc系列的性能, 因为需要遍历的块变少了

```
Results for mm malloc:
trace  valid  util     ops      secs  Kops
 0       yes   98%      12  0.000000     60000
 1       yes   99%      12  0.000000    120000
 2       yes   99%    5694  0.000187     30514
 3       yes  100%    5848  0.000161     36413
 4       yes   99%    6648  0.000192     34625
 5       yes  100%    5380  0.000178     30191
 6       yes   99%   14400  0.000115    125326
 7       yes   91%    4800  0.001722      2788
 8       yes   91%    4800  0.001804      2661
 9       yes   97%   12000  0.005751      2087
10       yes   90%   24000  0.022605      1062
11       yes  100%   14401  0.000100    144734
12       yes  100%   14401  0.000082    176483
Total          97%  112396  0.032895  3417

Perf index = 58 (util) + 40 (thru) = 98/100
```

# 3 简单分离存储

## 3.1 内存块格式, 在堆上的分布

> *显然这个方案会产生很多内存碎片, 因此只是简单实现, 不做过多优化*

将块大小按照**一定等价类组织成显式空闲链表**, 例如按照2的幂, 所有8, 16, 32 ... 字节的空闲块分别在一个显式链表里. 在当前实现中, 设置了10个常规list (从8到4096), 还有1个jumbo list用于储存大于4096的内存块. 

理论上链表越多性能越好, 例如按照以上的等价类, 申请1025大小的内存将分配2048的内存, 产生很多碎片; 但如果等价类更加细化, 内存碎片也会更少. 

这样的话: 

- 分配内存: 只需要检索特定的链表是否存在块
- 释放内存: 插入特定的链表, 而且可以直接LIFO插入链表头部
- 基本不需要合并: 这意味着块不需要footer, 堆也不需要prologue和epologue; **但jumbo list仍然需要合并**

对于每个链表, 只需要组织成单向链表, 这意味着每个空闲块只需要一个header标记大小和状态, 还有一个FDP (forward pointer); 而已经分配的块只需要一个header. 

在链表实现这一方面也有两种选择: 

- 链表头是一个伪结点 (包括header和fdp), 链表中无空闲块时FD指向NULL, 否则指向具体的地址
- 链表头只有fdp

## 3.2 mm_init

在当前实现中, 生成了11个链表头, 并且每个头都是伪结点, 因此需要先扩展11x2x4字节; 

同时为了extend heap分配的内存载荷部分是8字节内存对齐的, 需要用1个prologue块占位, 再需要一个epilogue块对齐. 

## 3.3 extend_heap

- 扩展内存
- 在header放置size

## 3.4 coalesce

如果当前bp和链表上下一个块紧邻, 就合并. 

## 3.5 mm_malloc

需要做几件事情:

1. 内存对齐
2. 找到对齐后, 应该被分配入哪个链表
3. 如果链表中能找到一个适配的块, 就分配; 否则扩展堆
4. 对于jumbo list, 需要在链表中找到一个尺寸合适的块; 
5. 对于普通list, 只需要判断链表中是否存在块即可, 反正同一链表中的块都一样大

## 3.6 find_prev_by_size/addr

该函数只检索list jumbo, 找到第一个**大小/地址**合适的curr块, 并且返回prev块; 因为这是个单向链表, 必须修改prev块的FD; 如果返回curr, 就没法找到prev了. 

## 3.7 list_map

输入一个size, 返回对应的链表头

## 3.8 mm_free

1. 检索block size, 以及属于哪个list
2. 对于普通list, 直接LIFO插入到链表开头, 不需要合并
3. 对于jumbo list, 查找**合适地址**的插入位置, 并且插入; 插入后执行合并

## 3.9 mm_realloc

如果申请的空间小于等于当前块的大小, 就直接返回; 否则就直接malloc, memcpy, free, 因为新的空间肯定属于另一个链表. 

除非这个块属于jumbo, 那可以直接扩展堆. 

## 3.10 得分

快是真的快, 但空间利用率也是真不高; 的确如同书上所说, 对于某些特定场景 (例如载荷的大小已知), 这种分配器将会很综合优势. 

```
Results for mm malloc:
trace  valid  util     ops      secs  Kops
 0       yes   65%      12  0.000000     60000
 1       yes   98%      12  0.000000     60000
 2       yes   96%    5694  0.000051    112752
 3       yes   94%    5848  0.000053    111390
 4       yes   98%    6648  0.000060    110985
 5       yes   98%    5380  0.000050    108468
 6       yes    0%   14400  0.000147     97826
 7       yes   81%    4800  0.000199     24157
 8       yes   82%    4800  0.000218     21998
 9       yes   50%   12000  0.000099    121827
10       yes   50%   24000  0.000176    136596
11       yes   59%   14401  0.000121    119017
12       yes   45%   14401  0.000079    182061
Total          71%  112396  0.001251 89823

Perf index = 42 (util) + 40 (thru) = 82/100
```

## 3.11 进一步探索: 更优秀的粒度

如果增加链表的数量, 理论上会提升空间利用率. 新增加了1536, 3072, 6144, 8192这几个链表, 并且有针对性地将4096调整到4104, 最终结果如下, 可见的确提升了一些利用率, 但仍然不高. 

```
Results for mm malloc:
trace  valid  util     ops      secs  Kops
 0       yes   65%      12  0.000000     60000
 1       yes   98%      12  0.000000     60000
 2       yes   96%    5694  0.000055    102780
 3       yes   93%    5848  0.000056    104242
 4       yes   98%    6648  0.000068     98198
 5       yes   98%    5380  0.000055     98355
 6       yes   50%   14400  0.000130    111111
 7       yes   84%    4800  0.000196     24527
 8       yes   84%    4800  0.000201     23928
 9       yes   50%   12000  0.000099    121581
10       yes   50%   24000  0.000180    133407
11       yes   48%   14401  0.000218     66029
12       yes   33%   14401  0.000116    124576
Total          73%  112396  0.001373 81891

Perf index = 44 (util) + 40 (thru) = 84/100
```

# 4 分离适配

## 4.1 内存块格式, 在堆上的分布

为了提高简单分离存储的空间利用率, 在上一个方案的基础上, 将(1, 16] 字节区间内的块组织为一个链表, (17, 32]的组织为另一个链表, 以此类推. 对于更大的尺寸, 这种等价类划分方式有显著优势, 例如分配4100的载荷时, 不必分配6144或者8192的块大小, 而是分配更精准的块大小. 

在这种组织形式中, 必须使用**显式空闲链表**, 因为同一等价类内的内存块不一定在堆上连续. 

考虑一下内存分配器的主要任务: 

- 找到一个空闲块: 沿着链表遍历, 找到匹配的空闲块 (例如第一个大小合适的块)
- 释放并且合并块: 如果只考虑同一个链表内的合并, 那就会减少很多合并的次数; 所以应该与内存上连续的**前一个/后一个**内存块合并, 即使这些待合并的块属于不同的链表. 
  - 既然需要**前一个/后一个**内存块, 那如果隐式空闲链表中所述, **每个块必须带有footer, 并且需要同时描述块大小和状态**
  - 需要状态为alloc的prologue和epilogue块, 避免错误合并
  - 另一个要考虑的因素是使用单向链表还是双向链表. 既然合并内存时要将待合并的前一个/后一个块从其对应的链表中分离出来, 那使用**双向链表**是比较合适的

在这种设计下, 每个内存块最小为16字节, 如果这个块已经被分配, 那最多可以容纳8字节的载荷; 如果是空闲的, 则将容纳header, fd, bk, footer四部分. 

## 4.2 mm_init

在初始化阶段, 可以为每个列表头只申请4字节的空间, 指向链表中第一个空闲块; 尽管我们确定了使用双向链表, 但并不需要header, bk, footer这些不会被访问的部分. 这样会**大大增加**写出bug的概率, 但也会略微减少一些内存消耗. 

在当前设计中, 使用了16, 32, ... , 8192的2次幂等价类序列, 以及一个jumbo list, 一共11个words; 在加上必备的prologue和epilogue, 刚好为14words, 满足8字节的内存对齐要求. 

## 4.3 extend_heap

仅仅扩展内存, 并且重新写一个epilogue, 将新分配的块标记为空闲的. 如前所述并不需要将该块链接到任何一个链表, 再加上epilogue和链表无关, 所以不需要任何链表操作. 

## 4.4 coalesce

和显式分离链表中的合并差不多, 查看内存上连续的**前一个/后一个块**的状态, 区别在于合并的块需要先从原先的链表中分离出来, 并且合并的后的块也必须**根据实际尺寸加入新的链表**. 不过为了保持语义, 在这个函数中我们并不加入新的链表, **单纯合并**. 

## 4.5 mm_malloc

- 找到了合适的块就放置
- 没找到就扩展内存, 并且直接指定状态为alloc

## 4.6 _get_list_index, get_list

本质上我们只需要根据一个大小返回一个index, 具体的列表头可以根据堆的起始位置 (全局变量) 加上偏移量得到. 

`_get_list_index`是个潜在的优化点, 如果能减少条件分支的性能损耗, 那结果会更好, 但显然throughput不是lab分数的瓶颈, 因此先忽视这个问题, 直接if-else就是干. 

## 4.7 search_block

该函数根据申请分配的大小, 查询是否有足够大的空闲块. 

- 根据大小, 可以确定所属的链表index, 小于该index的链表不必再查
- 用一个双层循环, 外层循环确定链表, 内层循环查找当前链表中是否有足够大的块
- 返回一个空闲块, 或者返回NULL



## 4.8 detach_block

将指定的块从链表中分离出来, 因为我们将空闲块组织为双向链表, 因此只需要将上一个/下一个块连接起来即可. 需要注意的是上一个块永远是存在的, 但下一个块可能为NULL

## 4.9 attach_block

在2.8中提到, 释放一个块, 或者说将一个块加入空闲链表时可以选择LIFO插入开头, 也可以按照地址排序. 

在显式空闲链表中, 我们的设计选择了按地址排序, 因为块没有footer, 只能通过链表决定是否合并空闲块. 

但在分离适配中, 是否合并空闲块是由内存上连续的内存块footer决定的, 因此链表不必是按照地址排序的, **可以选择LIFO方式**, 该方式可以在常数时间内合并, 而不必遍历链表来决定放置在何处. 

天平的一端是footer节约的内存, 另一端是运行效率, 我们稍后将看到两种方式的差异. 

但不管怎么说, 将一个块插入对应的双向链表都不是什么难事. 

## 4.10 place

分为以下三种情况: 

1. 如果块内剩余空间小于16字节: 无法分割, 直接放置
2. 分割后的空闲块仍然属于当前链表, 那么可以直接分配块的后部, 避免修改链表结构
3. 分割后的空闲块仍然属于其他链表, 那需要先detach, 分割后再coalesce, attach

## 4.11 mm_free

设置状态, 合并, attach

## 4.12 mm_realloc

如前所述, 分为三种情况: 

1. 申请更小的内存, 直接返回
2. 当前块位于堆末尾, 直接扩展
3. alloc, memcpy, free三件套

其实还有一种情况是: 申请更大内存 && 当前块不位于末尾 && 连续的后一个块恰好空闲 && 合并起来的尺寸可以满足条件. 不过实测并未触发这个条件, 因此删除了该条件分支. 



## 4.13 得分

如果我们在attach_block中选择了**按地址排序**, 那么结果如下; 和显式空闲链表的空间利用率差不多, 这是符合预期的; 效率 (以Kops计) 从1636提升至6731, 获得了显著提升. 

```
Results for mm malloc:
trace  valid  util     ops      secs  Kops
 0       yes   99%      12  0.000000     60000
 1       yes   99%      12  0.000000     60000
 2       yes   99%    5694  0.000095     60000
 3       yes  100%    5848  0.000095     61493
 4       yes   99%    6648  0.000116     57409
 5       yes  100%    5380  0.000087     61486
 6       yes   99%   14400  0.000122    118421
 7       yes   92%    4800  0.000437     10986
 8       yes   91%    4800  0.000441     10894
 9       yes   55%   12000  0.003059      3922
10       yes   51%   24000  0.011979      2004
11       yes  100%   14401  0.000137    105347
12       yes   87%   14401  0.000130    110607
Total          90%  112396  0.016698  6731

Perf index = 54 (util) + 40 (thru) = 94/100
```

如果改为**LIFO**, 结果如下所示. 这下更是快的没边, Kops暴涨至76010. 

```
Results for mm malloc:
trace  valid  util     ops      secs  Kops
 0       yes   99%      12  0.000000     60000
 1       yes   99%      12  0.000000    120000
 2       yes   97%    5694  0.000098     58280
 3       yes   95%    5848  0.000119     49019
 4       yes   98%    6648  0.000115     57758
 5       yes   99%    5380  0.000075     72021
 6       yes   99%   14400  0.000120    119701
 7       yes   88%    4800  0.000153     31311
 8       yes   87%    4800  0.000156     30848
 9       yes   55%   12000  0.000123     97879
10       yes   51%   24000  0.000254     94600
11       yes  100%   14401  0.000135    106595
12       yes   87%   14401  0.000131    109931
Total          89%  112396  0.001479 76010

Perf index = 53 (util) + 40 (thru) = 93/100
```

如果再加上2.11中的邪修方法 (初始化中预先申请2个载荷16的块, mm_malloc时针对binary修改尺寸), 最终得分如下:

```
Results for mm malloc:
trace  valid  util     ops      secs  Kops
 0       yes   98%      12  0.000000     60000
 1       yes   99%      12  0.000000     60000
 2       yes   97%    5694  0.000096     59561
 3       yes   95%    5848  0.000112     52214
 4       yes   98%    6648  0.000121     55079
 5       yes   99%    5380  0.000077     69961
 6       yes   98%   14400  0.000133    108108
 7       yes   88%    4800  0.000151     31704
 8       yes   87%    4800  0.000156     30730
 9       yes   97%   12000  0.000113    105820
10       yes   90%   24000  0.000233    103093
11       yes  100%   14401  0.000135    107071
12       yes  100%   14401  0.000095    151112
Total          96%  112396  0.001422 79019

Perf index = 58 (util) + 40 (thru) = 98/100
```

# 5 总结与展望

综合性能最好的5种结果的对比如下所示, 如果不针对性地使用邪修, 单纯从设计通用的动态内存分配器来考虑, **分离适配+LIFO+默认的first-fit**有最好的综合性能表现, 相比另外两个方案, 在略微降低空间利用率的同时大大提升了吞吐量, 是目前的局部最优解. 

尽管如此, 这肯定不是全局最优解: 事实上也很难有全局最优解, 毕竟工程上没有最好, 只有最合适. 

如果还想继续提升这个玩具级动态内存管理器的性能, 还可以从以下几个方面继续改进:

- 综合 first-fit 和 best-fit, 找到一个平衡点
- 减少条件分支的性能损耗
- 减小等价类的粒度
- 参考 libc malloc 和其他的优秀设计

# 6 Others

## 6.1 memlib

学生将使用这个库里的函数, 而不是系统调用

- mem_init: 申请20MB的堆内存 (根据config.h)
- mem_deinit: 释放这些内存
- mem_reset_brk: 重置brk指针位置为堆的初始位置
- mem_sbrk: 增长一些内存, 前提是不超过20MB的限制
- mem_heap_lo, mem_heap_hi: 实际使用的堆内存上下限
- mem_heapsize: 实际使用的堆内存大小
- mem_pagesize: 返回系统的pagesize

## 6.2 Debug and Run



```
clear; gcc -Wall -Og -m32 -DDEBUG -c -o mm.o mm.c; gcc -Wall -Og -m32 -DDEBUG -o mdriver mdriver.o mm.o memlib.o fsecs.o fcyc.o clock.o ftimer.o; ./mdriver -f ./traces/realloc-bal.rep -V > anal.dump

clear; gcc -Wall -O2 -m32 -c -o mm.o mm.c; gcc -Wall -O2 -m32 -o mdriver mdriver.o mm.o memlib.o fsecs.o fcyc.o clock.o ftimer.o; ./mdriver -V
```

## 6.3 future

heap 连续性检查 (`mm_check()`), 仅在debug时使用

- 是否有没合并的free blocks
- free list中是否每个block都被标记为free
- 是不是每个free block都在list中
- free list 中的是否真的free
- 是否有allocated blocks overlap
- heap block是否指向有效的heap address
