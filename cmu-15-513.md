# Number's Storage

## Bit Operator

- `&, |, ^, ~`, 位运算
- XOR: 相同为0, 不同为1
- `&&, ||, !`, 逻辑运算, 而且是短路的
- `<<`左移, 高位被低位取代, 低位被0填充: `0b0110,0010 << 3: 0b0001,0000`
- `>>`右移, 低位被高位取代, 高位被0或1填充
  - 逻辑右移: `0b1010,0010 >> 3: 0b0001,0100`
  - 算数右移: `0b1010,0010 >> 3: 0b1111,0100`



## Two’s Complement

unsigned vs signed (Two’s complement)

- `uint8`, 这很简单
- `int8`, 第一位为符号位, 0时正数, 1时负数
- `int8`表示

```
0b01111 = 15
0b11111 = -(0b0000+1) = -1
这个方法不好记, 另一个方法是, 如果最高位是1, 把它看成-2^5
0b11111 = -2^5
          +2^4 +2^3 +2^2 +2^1 +2^0 
        = -1
```

在C中, int占4bytes, 所以如果`int x = 0bFFFFFFFF`, 得到的就是-1

## Number Expand & Truncate

### Expanding

如果是uint, 那就直接填0好了; 如果我要将一个int8扩展为int16, 该如何做呢? 显然的:

- 对于正数, 什么都不用管, 在前面补0就好了
- 对于负数, 假如是从int8扩展为int9, 原本的第一位是`-2^7`, 现在变成了`+2^7`, 因此需要一个`-2^8`来抵消, 也就是在前面补一个1;
- 以此类推, 从int8到int16, 前面所有的数字都是1

**总结: 将原本的第一位复制到前面所有的位置上**



### Truncating

如果是uint: 

```
uint5   -> uint4
0b10100 -> 0b0100
20      -> 4

uint6    -> uint4
0b100100 -> uint0100
40       -> 4

Act like 40%(2^4) = 4
```

如果是正的int, 根据uint的规矩, 从uint n 到uint 4, 其实是对2^3取余. 

对于负的int, 该规律也一样, 对2^3取余: 只不过最终得到的是负数, 例如-29对8取余得到-5. 



## Add (Minus), Mul, Div, Pos/Neg

不管是有int还是uint, 都按照正常加法做就好了, 溢出也没关系, 溢出了也是对的. 

举例, -6加-3

```
-6   1010
-3   1101
---------
-9  10111 -> truncate -> 0111=7
```

这是正常的, -9超过了`[-8, 7]`的范围, 所以溢出成了7

---

乘法也是一样的, 例如int下, 5X5

```
5    0101
5    0101
----------
     0101
   0101
   -------
   011001 = 1001 = -7
```

btw, 这还说明了如果需要将一个数字x4, 只需要左移2位

---

除法就不太一样了, 是右移; 但对于int中的负数, 左侧补充的值应该能保持符号, 所以在左侧填充符号位, 例如: 

```
-6    1010
right shift 1 bit:
-3    1101
```

但如果要对-3/2呢?我们会得到

```
-3 1101  -> -2 1110
```

在C中, 计算这个除法时, 编译器会先给1101+1 = 1110(-2), 右移1位得到1111(-1). 这个偏移量是向0靠拢. 

在其他语言, 可能得到-2

---

取反+1, 例如 

```
            6    0110
flip all bits    1001
            +1   1010=-6
```

## Byte Ordering

> Big Endian, Little Endian

- 大端序：就像我们阅读一样符合直觉，地址低位的是开头，高位的是结束。常见于：**网络IO**
- 小端序：恰恰相反，一个数字的低位在地址高位，高位在地址低位；优点是性能好

> test_print_bytes.c

这个程序中，可以逐字节地查看内存，比如11451，对应int: `0x0000 2CBB`，但在内存中的存储情况为：

```
ADDR               VALUE
------------------------
000000d7c97ff77c    0xbb
000000d7c97ff77d    0x2c
000000d7c97ff77e    0x00
000000d7c97ff77f    0x00
```

## Float

小数点后第一位为$1/2$，第二位为$1/4$，以此类推，第i位为$\displaystyle\frac{1}{2^i}$。

但这么做有个问题，如果float固定只占32/64字节，小数点前的数字太少，则能表示的范围太少；如果增加表示范围，则小数点后的精度又不够，所以如何trade off是个问题。

关键就是要让小数点浮动起来，大概这也是命名为浮点数的原因。

---

### Normalized

float占32位，其中：

- S: Sign, 1 bit
- E: Exponent, 8 bits
- M: Mantissa, 23 bits

---

将数字转化为浮点数的步骤：

1. 将一个数字表示为2进制的形式，例如65.125，等于`0b0100 0001.0010`
2. 将这个数字normalized为`[1, 2)`之间的形式，或者说是科学计数法，`1.00 0001 0010 X 2^(6)`。注意，这里的偏移量**可正可负**
3. 小数点后的数字放在M区域内，这很正常
4. normalize后小数点前的1被省略了，这很牛逼——这也是为什么一定要让数字在`[1, 2)`区间内的原因
5. 指数的8位，如果用无符号数可以表示`[0, 255]`，如果用有符号数可以表示`[-128, 127]`
6. 有没有什么方法，能让表示范围更大呢？如果我固定地给指数+127的偏移量，这样指数的范围是：`[-127, 128]`，偏移后的范围刚好是8位u short的范围
7. 事实上，E域全0和全1是有特殊含义的，所以能表示的真实指数范围是`[-126, 127]`

---

一个实际的例子：

$5.75=1.0111\times2^2$

- 符号位 0
- 指数为2+127，无符号8位
- 尾数23位

最终答案是`0x40B8 0000`

---

这个例子有问题，无法表示0

### Denormalized

为了能表示0，令上面例子中的$5.75=0.10111\times2^3$。相比于规格化，非规格化浮点数的变化为：

- 为了表示相同范围的数字，非规格化需要给指数偏移126
- 可以表示0，而且有+0和-0



### Norm <-> Denorm

- 从Norm到Denorm，需要M域右移1位，并在最前面补0；E域不用动
- 从Denorm到Norm，也仅仅需要将M域左移1位

### Special Cases

之前提到了一点，E域全0和全1代表特殊情况。

- E域全1，M域全0：加法或者乘法溢出，代表$\pm\infty$
- E域全1，M域非全0：NaN



### Operations

- 加、减、乘都不能保证结果在区间内，可能会溢出；
- 更重要的是结果rounding，如何将float转化为int，或者是固定舍入到小数点后几位
  - to zero
  - down to -infinity
  - up to +infinity
  - near even



### Other Properties

- Commutative, 交换律
- NOT Associative, 结合律。在计算前会先对齐小数点，此时存在大数吃小数的情况，例如:
  - `1e2+(1e-10 - 1e-10)=1e2`
  - `(1e2+1e10)-1e10=0`
  - `(1e20*1e20)*1e-20=+inf`
  - `1e20*(1e20*1e-20)=1e20`
- 基于相同的原因，乘法也不满足分配律
- `int x; (int)(float) x`会导致精度损失，因为float-M只有23位，导致int的后8位被truncate掉了



# Machine-Level Coding: Assembly
